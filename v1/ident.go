package ident

import (
	"database/sql/driver"
	"errors"
	"time"
	"unicode"

	"github.com/bww/go-xid/v1"
)

const EncodedLength = 20

var errInvalidLength = errors.New("Invalid length")

var (
	dst = xid.NewGenerator(xid.Distributed)
	seq = xid.NewGenerator(xid.Sequential)
)

var Zero = Ident{}

type Ident xid.ID

// New generates a new distributed identifier, which is expected to generally
// sort with an even distribution relative to all other identifiers generated
// by this method. That is, forany identifier X, any other identifier generated
// after it, Y, has a roughly equal likelihood that X < Y or X > Y.
func New() Ident {
	return Ident(dst.New())
}

// Asc generates a new identifier which orders lexigraphically in ascending
// order relative to all other identifiers generated by this method. That is,
// for any identifier X, any other identifier generated after it, Y, has the
// property that X < Y.
func Asc() Ident {
	return Ident(seq.New())
}

// Dsc generates a new identifier which orders lexigraphically in descending
// order relative to all other identifiers generated by this method. That is,
// for any identifier X, any other identifier generated after it, Y, has the
// property that X > Y.
func Dsc() Ident {
	return Invert(Asc())
}

// AscWithTime generates a new identifier which orders lexigraphically in
// ascending order relative to all other identifiers generated by this method
// using the same reference time.
func AscWithTime(t time.Time) Ident {
	return Ident(seq.NewWithTime(t))
}

// DscWithTime generates a new identifier which orders lexigraphically in
// ascending order relative to all other identifiers generated by this method
// using the same reference time.
func DscWithTime(t time.Time) Ident {
	return Invert(SeqWithTime(t))
}

// Invert reverses the ordering of the provided identifier.
func Invert(v Ident) Ident {
	var r Ident
	l := len(r)
	for i := 0; i < l; i++ {
		r[i] = 0xff - v[i]
	}
	return r
}

// Parse parses an identifier from its encoded string representation.
func Parse(s string) (Ident, error) {
	x, err := dst.FromString(s) // the generator used doesn't actually affect parsing
	if err != nil {
		return Zero, err
	}
	return Ident(x), nil
}

// MustParse should really only ever be used in tests
func MustParse(s string) Ident {
	v, err := Parse(s)
	if err != nil {
		panic(err)
	}
	return v
}

// FromBytes converts an identifier from its binary representation.
func FromBytes(b []byte) (Ident, error) {
	var id Ident
	if len(b) != len(id) {
		return id, errInvalidLength
	}
	copy(id[:], b)
	return id, nil
}

func (v Ident) String() string {
	return xid.ID(v).String()
}

func (v Ident) IsZero() bool {
	return xid.ID(v).IsZero()
}

func (v Ident) Compare(x Ident) int {
	return xid.ID(v).Compare(xid.ID(x))
}

func (v Ident) Before(x Ident) bool {
	return v.Compare(x) < 0
}

func (v Ident) After(x Ident) bool {
	return v.Compare(x) > 0
}

func (v Ident) MarshalText() ([]byte, error) {
	return xid.ID(v).MarshalText()
}

func (v *Ident) UnmarshalText(t []byte) error {
	return (*xid.ID)(v).UnmarshalText(t)
}

func (v Ident) MarshalJSON() ([]byte, error) {
	return xid.ID(v).MarshalJSON()
}

func (v *Ident) UnmarshalJSON(b []byte) error {
	return (*xid.ID)(v).UnmarshalJSON(b)
}

func (v Ident) Value() (driver.Value, error) {
	return xid.ID(v).Value()
}

func (v *Ident) Scan(value interface{}) error {
	return (*xid.ID)(v).Scan(value)
}

// ResemblesIdent returns true if the input has the general format of an
// encoded identifier; specifically, this is the case if the input is 20 bytes
// long and contains only uppercase letters and digits. (Technically, this is
// sligtly more inclusive than the actual alphabet for identifiers, but it is
// suitable for this purpose.)
//
// This, of course does not mean that the input is actually intended to be an
// identifier, just that it could be one.
func ResemblesIdent(v string) bool {
	if len(v) != EncodedLength {
		return false
	}
	for _, c := range v {
		if !(unicode.IsUpper(c) || unicode.IsDigit(c)) {
			return false
		}
	}
	return true
}
